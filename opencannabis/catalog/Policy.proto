
/**
 * Specifies structures that form policies that apply within a given catalog scope. "Catalog Policies" allow app users
 * to specify requirements or suggestions for their content, which are used to either enforce that matching products
 * comply, or warn users when they don't. Some policies are system-builtin, and some are added by users.
 */
syntax = "proto3";

package opencannabis.catalog.policy;

option optimize_for = SPEED;
option objc_class_prefix = "OCS";
option java_package = "io.opencannabis.schema.catalog.policy";
option java_multiple_files = false;
option java_outer_classname = "CatalogPolicies";

import "gust/core/datamodel.proto";

import "opencannabis/base/ProductKind.proto";
import "opencannabis/temporal/Instant.proto";
import "opencannabis/identity/UserKey.proto";
import "opencannabis/catalog/PolicyKey.proto";

import "google/protobuf/struct.proto";
import "google/protobuf/field_mask.proto";


// Enforcement effect options that can be attached to a content template. At the user's discretion, users can be warned
// when publishing a product that doesn't comply with a given policy, or they can outright be prevented from executing
// the publish operation.
enum PolicyEffect {
  // Sum-up effects but don't enforce or warn.
  NONE = 0;

  // Warn the user before publishing a product that does not comply.
  WARN = 1;

  // Enforce the template, preventing a user from publishing a product that does not comply.
  ENFORCE = 2;
}


// Defines the set of supported operators, when matching against a given property or computed value between a product
// record and a catalog policy.
enum PolicyOperator {
  // Unknown policy operator.
  UNKNOWN_POLICY_OPERATOR = 0;

  // The property must be set.
  SET = 1;

  // The property must not be set.
  UNSET = 2;

  // The property must equal some value.
  EQUALS = 3;

  // The property must not equal some value.
  NOT_EQUALS = 4;

  // The property must be greater than some value.
  GREATER_THAN = 5;

  // The property must be greater-than-or-equal-to some value.
  GREATER_THAN_EQUAL_TO = 6;

  // The property must be less than some value.
  LESS_THAN = 7;

  // The property must be less-than-or-equal-to some value.
  LESS_THAN_EQUAL_TO = 8;

  // The property must be an array or string, and contain some value.
  CONTAINS = 9;

  // The property must be an array or string, and not contain some value.
  NOT_CONTAINS = 10;
}


// Defines a conjunction which links a match query stanza, either via `AND` or `OR`. This governs how the stanza is
// applied relative to the previous one in the query. The first stanza's conjunction has no effect.
enum PolicyMatchConjunction {
  // Filter the previous stanza's results by this stanza's criteria. This functionally produces an `AND` query.
  AND = 0;

  // Combine the previous stanza's results with this stanza's criteria. This functionally produces an `OR` query.
  OR = 1;
}


// Enumerates the types of match stanzas that may be applied to a policy match query. This describes how the stanza in
// question is matched against product records.
enum PolicyMatchType {
  // Unknown match stanza type.
  UNKNOWN_MATCH_TYPE = 0;

  // The match stanza matches products by their category.
  BY_CATEGORY = 1;

  // The match stanza matches products by model property criteria.
  BY_PROPERTY = 2;
}


// Describes a query which is used to match against catalog products, so that it may be determined if a given policy
// should apply to the subject product.
message PolicyMatchQuery {
  // Defines match criteria based on one or more product types/sections. Section match stanzas are applied before all
  // other stanza types, and are inclusive (since products may only have one section/kind).
  message KindMatch {
    // Specifies kinds of products to match.
    repeated opencannabis.base.ProductKind kind = 1;
  }

  // Defines match criteria based on some arbitrary product property value. In this case, we map the field the user is
  // matching against using a field mask, specify an operator, and, potentially, a value of some kind.
  message PropertyMatch {
    // Specifies the property to match against.
    google.protobuf.FieldMask property = 1;

    // Operator to apply when matching against this field.
    PolicyOperator operator = 2;

    // Value to specify as an attachment to this match query.
    google.protobuf.Value value = 3;
  }

  // Describes an individual stanza that, together with its peers, constitutes the match query for a given catalog
  // policy. Policies queries can specify multiple match stanzas.
  message MatchStanza {
    // Conjunction that links this stanza with the previous one. This property has no effect for the first stanza
    // included in the policy match query.
    PolicyMatchConjunction conjunction = 1;

    // Specifies the match criteria that constitutes this stanza.
    oneof match {
      // Specifies match criteria by filtering against a product's section/kind.
      KindMatch section = 2;

      // Specifies match criteria that filters against a model property or value.
      PropertyMatch property = 3;

      // Flag indicating this match stanza should match all products.
      bool all = 4;
    }
  }

  // Specifies the set of match stanzas that constitute this policy match query.
  repeated MatchStanza stanza = 1;
}


// Enumerates types of constraints that may be enforced or computed against product records.
enum ConstraintType {
  // Unknown constraint type.
  UNKNOWN_CONSTRAINT_TYPE = 0;

  // Specifies a constraint applied to a model property.
  PROPERTY = 1;

  // Specifies a constraint applied to a model's neighbors.
  REFERENCE = 2;

  // Specifies a constraint applied to creative assets linked to a product.
  CREATIVE = 3;
}


// Specifies flags which may be flipped when specifying property constraints for a catalog policy.
message PropertyConstraintFlags {
  // Stipulate that the property value must be unique.
  bool unique = 1;
}


// Specifies a property-based constraint applied to a set of products via a catalog policy, which stipulates that
// certain model properties comply with the enclosed criteria.
message PropertyConstraint {
  // Specifies the property to apply this constraint to.
  google.protobuf.FieldMask property = 1;

  // Operator to apply when constraining this field.
  PolicyOperator operator = 2;

  // Value to specify as an attachment to this constraint.
  google.protobuf.Value value = 3;

  // Constraint flags for matched property values.
  PropertyConstraintFlags flags = 4;
}


// Specifies a constraint applied to a set of products via a catalog policy, which stipulates that certain records must
// be linked/referenced and existing, as neighbors to the subject record.
message ReferenceConstraint {
  // (coming soon)
}


// Specifies a constraint applied to linked product creative. For instance, required documents, or required media, or
// required media criteria (certain sizing, resolution, and so on).
message CreativeConstraint {
  // (coming soon)
}


// Specifies a constraint which, when included in a policy that matches a given product, is calculated against the given
// product to determine compliance of the record with the constraint criteria.
message PolicyConstraint {
  // Specifies the type of this constraint record.
  ConstraintType type = 1;

  // Specifies the stipulation provided by this constraint.
  oneof stipulation {
    // Stipulates that a property behave or be set a certain way.
    PropertyConstraint property = 10;

    // Stipulates that a referential relationship must exist or must not exist.
    ReferenceConstraint reference = 11;

    // Stipulates that a creative asset must fulfill some need.
    CreativeConstraint creative = 12;
  }
}


// Enumerates the statuses a catalog policy may take on.
enum PolicyStatus {
  // Unknown policy status.
  UNKNOWN_POLICY_STATUS = 0;

  // The policy is not active, and will not be considered.
  INACTIVE = 1;

  // The policy is active and will be considered for matching products.
  ACTIVE = 2;
}


// Defines the notion of a "Catalog Policy," which allows back-office users to specify restrictions or constraints for
// their catalog products. These policies must be complied-with, as-configured, when the user is creating products in
// the catalog scope which owns the policy.
//
// Policies have a few main components that, together, form a flow of functional logic:
// - The policy is processed according to `STATUS` - i.e., only if it is `ACTIVE`.
// - Iff a given product, upon write or publish, matches the criteria specified as `match`,
// - Then the configured `constraint` is tested against the product.
// - Iff the product does not comply with `constraint`, `effect` is applied as the subsequent course of action.
//
// A short note about match queries:
// Products can be matched based on arbitrary criteria, combined into a "policy match query." Each "stanza" in the query
// can specify (1) section-based filters, or (2) property-based filters. These values are collapsed upon product record
// write so they can be enforced or used to warn the user.
//
// A short note about constraints:
// Policy-based constraints can be applied to two major functions (at time of this writing). These can be (1) property-
// based constraints, or referential constraints. Property constraints apply some constraining logic to a given model
// property, and referential constraints specify required neighbor records.
//
// How policy effects work:
// Depending on whether the (1) product matches and (2) doesn't comply, an `effect` may be applied. Effects available at
// the time of this writing include `WARN`, which warns the user before allowing a save to occur, and `ENFORCE`, which
// actively prevents the user from saving a non-compliant record.
message CatalogPolicy {
  option (core.db) = {
    mode: GROUP
    path: "constraints"
  };

  // Specifies the key for this catalog policy.
  PolicyKey key = 1 [(core.field).type = KEY];

  // Human-friendly name for this policy.
  string name = 2;

  // Current status of this policy - determines whether it is considered.
  PolicyStatus status = 3;

  // Long-form description for this catalog policy.
  string description = 4;

  // Effect to apply for matching but non-compliant products.
  PolicyEffect effect = 5;

  // Match query to use when determining whether this policy applies to a given product.
  PolicyMatchQuery match = 6;

  // Constraint to apply to a given product if it matches this policy.
  PolicyConstraint constraint = 7;

  // Who last modified this policy.
  bloombox.identity.UserKey modified_by = 96;

  // When this policy was last modified.
  opencannabis.temporal.Instant modified_at = 97 [
    (core.field).stamp_update = true
  ];

  // Who originally created this policy.
  bloombox.identity.UserKey created_by = 98;

  // When this policy was originally created.
  opencannabis.temporal.Instant created_at = 99 [
    (core.field).stamp_create = true
  ];
}
